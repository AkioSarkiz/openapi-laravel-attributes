{"version":3,"file":"index.modern.js","sources":["../../src/index.ts"],"sourcesContent":["/**\n * A function that emits a side effect.\n */\nexport type Procedure = (...args: any[]) => any;\n\nexport type Options<TT> = {\n  isImmediate?: boolean;\n  maxWait?: number;\n  callback?: (data: TT) => void\n};\n\nexport interface DebouncedFunction<F extends Procedure> {\n  (this: ThisParameterType<F>, ...args: Parameters<F>): Promise<ReturnType<F>>;\n  cancel: (reason?: any) => void;\n}\n\nexport function debounce<F extends Procedure>(\n  func: F,\n  waitMilliseconds = 50,\n  options: Options<ReturnType<F>> = {}\n): DebouncedFunction<F> {\n  let timeoutId: ReturnType<typeof setTimeout> | undefined;\n  const isImmediate = options.isImmediate ?? false;\n  const callback = options.callback ?? false;\n  const maxWait = options.maxWait;\n  let lastInvokeTime = Date.now();\n\n  let promises: {\n    resolve: (x: ReturnType<F>) => void\n    reject: (reason?: any) => void\n  }[] = []\n\n  function nextInvokeTimeout() {\n    if (maxWait !== undefined) {\n      const timeSinceLastInvocation = Date.now() - lastInvokeTime;\n\n      if (timeSinceLastInvocation + waitMilliseconds >= maxWait) {\n        return maxWait - timeSinceLastInvocation;\n      }\n    }\n\n    return waitMilliseconds;\n  }\n\n  const debouncedFunction = function (\n    this: ThisParameterType<F>,\n    ...args: Parameters<F>\n  ) {\n    const context = this;\n    return new Promise<ReturnType<F>>((resolve, reject) => {\n      const invokeFunction = function () {\n        timeoutId = undefined;\n        lastInvokeTime = Date.now();\n        if (!isImmediate) {\n          const result = func.apply(context, args)\n          callback && callback(result);\n          promises.forEach(({ resolve }) => resolve(result))\n          promises = []\n        }\n      };\n\n      const shouldCallNow = isImmediate && timeoutId === undefined;\n\n      if (timeoutId !== undefined) {\n        clearTimeout(timeoutId);\n      }\n\n      timeoutId = setTimeout(invokeFunction, nextInvokeTimeout());\n\n      if (shouldCallNow) {\n        const result = func.apply(context, args)\n        callback && callback(result);\n        return resolve(result)\n      }\n      promises.push({ resolve, reject })\n    })\n\n  };\n\n  debouncedFunction.cancel = function (reason?: any) {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n    }\n    promises.forEach(({ reject }) => reject(reason))\n    promises = []\n  };\n\n  return debouncedFunction;\n}\n"],"names":["debounce","func","waitMilliseconds","options","timeoutId","isImmediate","callback","maxWait","lastInvokeTime","Date","now","promises","debouncedFunction","args","context","this","Promise","resolve","reject","shouldCallNow","undefined","clearTimeout","setTimeout","result","apply","forEach","timeSinceLastInvocation","nextInvokeTimeout","push","cancel","reason"],"mappings":"SAgBgBA,EACdC,EACAC,EAAmB,GACnBC,EAAkC,YAElC,IAAIC,EACJ,MAAMC,WAAcF,EAAQE,gBACtBC,WAAWH,EAAQG,aACnBC,EAAUJ,EAAQI,QACxB,IAAIC,EAAiBC,KAAKC,MAEtBC,EAGE,GAcN,MAAMC,EAAoB,YAErBC,GAEH,MAAMC,EAAUC,KAChB,WAAWC,QAAuB,CAACC,EAASC,KAC1C,MAWMC,EAAgBd,QAA6Be,IAAdhB,EAQrC,QANkBgB,IAAdhB,GACFiB,aAAajB,GAGfA,EAAYkB,WAjBW,WAGrB,GAFAlB,OAAYgB,EACZZ,EAAiBC,KAAKC,OACjBL,EAAa,CAChB,MAAMkB,EAAStB,EAAKuB,MAAMV,EAASD,GACnCP,GAAYA,EAASiB,GACrBZ,EAASc,QAAQ,EAAGR,QAAAA,KAAcA,EAAQM,IAC1CZ,EAAW,KAzBnB,WACE,QAAgBS,IAAZb,EAAuB,CACzB,MAAMmB,EAA0BjB,KAAKC,MAAQF,EAE7C,GAAIkB,EAA0BxB,GAAoBK,EAChD,OAAOA,EAAUmB,EAIrB,OAAOxB,EA0BkCyB,IAEnCR,EAAe,CACjB,MAAMI,EAAStB,EAAKuB,MAAMV,EAASD,GAEnC,OADAP,GAAYA,EAASiB,GACdN,EAAQM,GAEjBZ,EAASiB,KAAK,CAAEX,QAAAA,EAASC,OAAAA,OAa7B,OARAN,EAAkBiB,OAAS,SAAUC,QACjBV,IAAdhB,GACFiB,aAAajB,GAEfO,EAASc,QAAQ,EAAGP,OAAAA,KAAaA,EAAOY,IACxCnB,EAAW,IAGNC"}